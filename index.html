<!DOCTYPE html>
<html>
<head>
    <title>üìç Smart Location Check</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 20px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #2D8CFF;
            text-align: center;
            margin-bottom: 5px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
        }
        .btn {
            background: linear-gradient(135deg, #2D8CFF 0%, #1A7AE6 100%);
            color: white;
            border: none;
            padding: 18px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            width: 100%;
            margin: 15px 0;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(42, 139, 242, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 139, 242, 0.4);
        }
        .result {
            margin-top: 25px;
            padding: 25px;
            border-radius: 12px;
            background: #f8f9fa;
            border-left: 5px solid #2D8CFF;
            transition: all 0.3s ease;
        }
        .verified {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        .warning {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
        .suspicious {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        .status-box {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
        }
        .good { background: #d4edda; color: #155724; }
        .medium { background: #fff3cd; color: #856404; }
        .bad { background: #f8d7da; color: #721c24; }
        .info-box {
            background: #e7f3ff;
            padding: 20px;
            border-radius: 10px;
            margin-top: 25px;
            border-left: 4px solid #2D8CFF;
        }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .metric-score {
            font-weight: bold;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 14px;
        }
        .score-good { background: #28a745; color: white; }
        .score-medium { background: #ffc107; color: #212529; }
        .score-bad { background: #dc3545; color: white; }
        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-family: monospace;
            font-size: 16px;
            margin: 15px 0;
            resize: vertical;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìç SMART LOCATION VERIFICATION</h1>
        <p class="subtitle">Intelligently detects fake GPS on normal phones</p>
        
        <button class="btn" onclick="checkSmartLocation()">
            üîç VERIFY MY REAL LOCATION
        </button>
        
        <div id="status"></div>
        
        <div id="result"></div>
        
        <div class="info-box">
            <h3>ü§ñ Smart Detection Logic:</h3>
            <p>‚Ä¢ Understands normal GPS vs IP differences (20-100km OK)</p>
            <p>‚Ä¢ Detects impossible accuracy (0m = likely fake)</p>
            <p>‚Ä¢ Checks for VPN/Proxy masking</p>
            <p>‚Ä¢ Validates movement patterns</p>
        </div>
    </div>

    <script>
    // Smart location verification that understands normal phone behavior
    async function checkSmartLocation() {
        showStatus('üîÑ Analyzing location patterns...', 'info');
        
        try {
            // Get multiple data points
            const [gpsData, ipData, networkData, vpnCheck] = await Promise.all([
                getSmartGPS(),
                getSmartIPLocation(),
                getNetworkInfo(),
                checkForVPN()
            ]);
            
            // Calculate trust score (0-100)
            const trustScore = calculateTrustScore(gpsData, ipData, networkData, vpnCheck);
            
            // Determine if location is real
            const isReal = trustScore >= 70;
            const warnings = analyzeWarnings(gpsData, ipData, vpnCheck);
            
            // Display smart results
            displaySmartResults(gpsData, ipData, trustScore, isReal, warnings);
            
        } catch (error) {
            showStatus('‚ùå Error: ' + error.message, 'error');
        }
    }
    
    // Smart GPS collection with multiple checks
    function getSmartGPS() {
        return new Promise((resolve, reject) => {
            let positions = [];
            let watchId;
            let checks = 0;
            
            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    positions.push({
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy,
                        speed: position.coords.speed,
                        heading: position.coords.heading,
                        timestamp: position.timestamp
                    });
                    
                    checks++;
                    
                    // Collect 3 readings then analyze
                    if (checks >= 3) {
                        navigator.geolocation.clearWatch(watchId);
                        
                        const avgPosition = analyzeGPSReadings(positions);
                        resolve(avgPosition);
                    }
                },
                (error) => reject(error),
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 10000
                }
            );
            
            // Timeout after 15 seconds
            setTimeout(() => {
                navigator.geolocation.clearWatch(watchId);
                if (positions.length > 0) {
                    resolve(analyzeGPSReadings(positions));
                } else {
                    reject(new Error('GPS timeout'));
                }
            }, 15000);
        });
    }
    
    // Analyze multiple GPS readings
    function analyzeGPSReadings(positions) {
        if (positions.length === 0) return null;
        
        // Calculate averages
        const avgLat = positions.reduce((sum, pos) => sum + pos.lat, 0) / positions.length;
        const avgLon = positions.reduce((sum, pos) => sum + pos.lon, 0) / positions.length;
        const avgAccuracy = positions.reduce((sum, pos) => sum + pos.accuracy, 0) / positions.length;
        
        // Check for consistency (real GPS moves slightly, fake GPS is often static)
        let isConsistent = true;
        let maxVariation = 0;
        
        if (positions.length > 1) {
            for (let i = 1; i < positions.length; i++) {
                const distance = calculateDistance(
                    positions[i-1].lat, positions[i-1].lon,
                    positions[i].lat, positions[i].lon
                );
                maxVariation = Math.max(maxVariation, distance);
            }
            
            // Normal phones: 0-50m variation between readings
            // Fake GPS: Often 0m (exact same coordinates) or huge jumps
            if (maxVariation > 1000) { // >1km between readings
                isConsistent = false;
            }
        }
        
        // Check for suspicious patterns
        const suspiciousPatterns = {
            perfectAccuracy: avgAccuracy < 1, // Less than 1m accuracy (suspicious on phone)
            zeroAltitude: positions.every(p => p.altitude === 0), // Fake GPS often has altitude 0
            noAltitudeAccuracy: positions.every(p => p.altitudeAccuracy === null),
            noSpeed: positions.every(p => p.speed === null), // No movement data
            noHeading: positions.every(p => p.heading === null) // No direction data
        };
        
        return {
            lat: avgLat,
            lon: avgLon,
            accuracy: avgAccuracy,
            readings: positions.length,
            consistency: isConsistent,
            maxVariation: maxVariation,
            suspicious: suspiciousPatterns,
            trustScore: calculateGPSTrust(avgAccuracy, suspiciousPatterns, maxVariation)
        };
    }
    
    // Smart IP location with multiple fallbacks
    async function getSmartIPLocation() {
        const services = [
            'https://ipapi.co/json/',
            'https://ipinfo.io/json',
            'https://geolocation-db.com/json/'
        ];
        
        for (const service of services) {
            try {
                const response = await fetch(service);
                const data = await response.json();
                
                let lat, lon, city, country, isp;
                
                // Parse different API formats
                if (data.latitude && data.longitude) {
                    lat = data.latitude;
                    lon = data.longitude;
                } else if (data.loc) {
                    [lat, lon] = data.loc.split(',');
                }
                
                city = data.city || data.region || '';
                country = data.country_name || data.country || '';
                isp = data.org || data.isp || '';
                
                // Calculate IP location accuracy (city-level = ~20km radius)
                const ipAccuracy = city ? 20000 : 50000; // City known: ~20km, country only: ~50km
                
                return {
                    lat: parseFloat(lat) || 0,
                    lon: parseFloat(lon) || 0,
                    city: city,
                    country: country,
                    isp: isp,
                    accuracy: ipAccuracy,
                    trustScore: calculateIPTrust(isp, city)
                };
                
            } catch (error) {
                continue; // Try next service
            }
        }
        
        throw new Error('All IP services failed');
    }
    
    // Get network information
    async function getNetworkInfo() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        
        return {
            type: connection ? connection.effectiveType : 'unknown',
            downlink: connection ? connection.downlink : 'unknown',
            rtt: connection ? connection.rtt : 'unknown',
            saveData: connection ? connection.saveData : false,
            isMobile: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
        };
    }
    
    // Check for VPN/Proxy
    async function checkForVPN() {
        try {
            const response = await fetch('https://ipapi.co/json/');
            const data = await response.json();
            
            const isp = data.org || '';
            const ispLower = isp.toLowerCase();
            
            // Common VPN/Proxy/Hosting indicators
            const vpnKeywords = ['vpn', 'proxy', 'tor', 'anonymizer', 'privacy'];
            const hostingKeywords = ['hosting', 'datacenter', 'server', 'cloud', 'aws', 'azure', 'google cloud', 'digitalocean', 'linode', 'vultr'];
            
            let isVPN = vpnKeywords.some(keyword => ispLower.includes(keyword));
            let isHosting = hostingKeywords.some(keyword => ispLower.includes(keyword));
            
            return {
                isVPN: isVPN,
                isHosting: isHosting,
                isp: isp,
                trustScore: isVPN || isHosting ? 30 : 80
            };
            
        } catch {
            return { isVPN: false, isHosting: false, trustScore: 50 };
        }
    }
    
    // Calculate overall trust score (0-100)
    function calculateTrustScore(gps, ip, network, vpn) {
        let score = 0;
        let weights = 0;
        
        // GPS trust (40% weight)
        if (gps && gps.trustScore) {
            score += gps.trustScore * 0.4;
            weights += 0.4;
        }
        
        // IP trust (30% weight)
        if (ip && ip.trustScore) {
            score += ip.trustScore * 0.3;
            weights += 0.3;
        }
        
        // VPN trust (20% weight)
        if (vpn && vpn.trustScore) {
            score += vpn.trustScore * 0.2;
            weights += 0.2;
        }
        
        // Network trust (10% weight)
        if (network && network.isMobile) {
            score += 80 * 0.1; // Mobile gets higher trust
            weights += 0.1;
        }
        
        // Normalize score
        if (weights > 0) {
            return Math.round(score / weights);
        }
        
        return 50; // Default middle score
    }
    
    // Calculate GPS trust score
    function calculateGPSTrust(accuracy, suspicious, maxVariation) {
        let score = 70; // Base score
        
        // Adjust based on accuracy (normal phone GPS: 10-100m)
        if (accuracy < 10) score -= 30; // Too accurate = suspicious
        else if (accuracy <= 50) score += 20; // Good accuracy
        else if (accuracy <= 200) score += 10; // Normal accuracy
        else if (accuracy > 1000) score -= 20; // Poor accuracy
        
        // Check suspicious patterns
        if (suspicious.perfectAccuracy) score -= 40;
        if (suspicious.zeroAltitude) score -= 15;
        if (suspicious.noSpeed) score -= 10;
        
        // Check consistency
        if (maxVariation > 10000) score -= 30; // Huge jumps
        else if (maxVariation > 1000) score -= 20; // Large jumps
        else if (maxVariation > 100) score -= 5; // Normal movement
        
        return Math.max(0, Math.min(100, score));
    }
    
    // Calculate IP trust score
    function calculateIPTrust(isp, city) {
        let score = 60; // Base score
        
        // ISP-based scoring
        const ispLower = isp.toLowerCase();
        if (ispLower.includes('mobile') || ispLower.includes('cellular') || ispLower.includes('wireless')) {
            score += 20; // Mobile ISP = more trust
        }
        
        if (ispLower.includes('vpn') || ispLower.includes('proxy')) {
            score -= 40; // VPN/Proxy = less trust
        }
        
        if (ispLower.includes('hosting') || ispLower.includes('datacenter')) {
            score -= 30; // Hosting = less trust
        }
        
        // City-level accuracy
        if (city) score += 10; // City known = more trust
        
        return Math.max(0, Math.min(100, score));
    }
    
    // Analyze warnings
    function analyzeWarnings(gps, ip, vpn) {
        const warnings = [];
        
        if (!gps) {
            warnings.push('No GPS data available');
            return warnings;
        }
        
        // GPS warnings
        if (gps.accuracy < 5) {
            warnings.push('Suspiciously perfect GPS accuracy (<5m)');
        }
        
        if (gps.suspicious.zeroAltitude) {
            warnings.push('Altitude data missing (common in fake GPS)');
        }
        
        if (gps.suspicious.noSpeed && gps.suspicious.noHeading) {
            warnings.push('No movement/direction data');
        }
        
        if (gps.maxVariation > 10000) {
            warnings.push('GPS coordinates jumped significantly');
        }
        
        // VPN warnings
        if (vpn.isVPN) {
            warnings.push('VPN/Proxy detected');
        }
        
        if (vpn.isHosting) {
            warnings.push('Hosting/datacenter IP detected');
        }
        
        return warnings;
    }
    
    // Display smart results
    function displaySmartResults(gps, ip, trustScore, isReal, warnings) {
        let resultClass = 'verified';
        let statusText = '‚úÖ LOCATION VERIFIED';
        let statusClass = 'good';
        
        if (trustScore >= 80) {
            statusText = '‚úÖ HIGHLY TRUSTED LOCATION';
            statusClass = 'good';
            resultClass = 'verified';
        } else if (trustScore >= 60) {
            statusText = '‚ö†Ô∏è MODERATELY TRUSTED';
            statusClass = 'medium';
            resultClass = 'warning';
        } else {
            statusText = 'üö® SUSPICIOUS LOCATION';
            statusClass = 'bad';
            resultClass = 'suspicious';
        }
        
        // Calculate GPS-IP distance
        let distance = 0;
        if (gps && ip && ip.lat !== 0) {
            distance = calculateDistance(gps.lat, gps.lon, ip.lat, ip.lon);
        }
        
        // Smart distance interpretation
        let distanceStatus = 'Normal';
        let distanceClass = 'score-good';
        
        if (distance === 0) {
            distanceStatus = 'Unknown';
            distanceClass = 'score-medium';
        } else if (distance < 20000) { // <20km
            distanceStatus = 'Excellent';
            distanceClass = 'score-good';
        } else if (distance < 100000) { // <100km
            distanceStatus = 'Normal (mobile)';
            distanceClass = 'score-medium';
        } else if (distance < 500000) { // <500km
            distanceStatus = 'Large';
            distanceClass = 'score-medium';
        } else { // >500km
            distanceStatus = 'Suspicious';
            distanceClass = 'score-bad';
        }
        
        let resultHTML = `
            <div class="status-box ${statusClass}">
                <h2 style="margin:0;">${statusText}</h2>
                <p style="margin:5px 0 0 0; font-size:24px; font-weight:bold;">Trust Score: ${trustScore}/100</p>
            </div>
            
            <h3>üìä Location Metrics:</h3>
            
            <div class="metric">
                <span>GPS Accuracy:</span>
                <span class="metric-score ${gps.accuracy < 50 ? 'score-good' : gps.accuracy < 200 ? 'score-medium' : 'score-bad'}">
                    ${Math.round(gps.accuracy)} meters
                </span>
            </div>
            
            <div class="metric">
                <span>GPS Consistency:</span>
                <span class="metric-score ${gps.consistency ? 'score-good' : 'score-bad'}">
                    ${gps.consistency ? 'Stable' : 'Unstable'}
                </span>
            </div>
            
            <div class="metric">
                <span>GPS vs IP Distance:</span>
                <span class="metric-score ${distanceClass}">
                    ${Math.round(distance/1000)} km (${distanceStatus})
                </span>
            </div>
            
            <div class="metric">
                <span>ISP Type:</span>
                <span class="metric-score ${ip.trustScore > 60 ? 'score-good' : ip.trustScore > 40 ? 'score-medium' : 'score-bad'}">
                    ${ip.isp || 'Unknown'}
                </span>
            </div>
        `;
        
        // Display coordinates
        resultHTML += `
            <h3>üìç Your Coordinates:</h3>
            <div style="background:#e9ecef; padding:15px; border-radius:8px; margin:15px 0;">
                <p><strong>GPS (Exact):</strong> ${gps.lat.toFixed(6)}, ${gps.lon.toFixed(6)}</p>
                <p><strong>IP (Approximate):</strong> ${ip.lat.toFixed(6)}, ${ip.lon.toFixed(6)}</p>
                <p><strong>City (from IP):</strong> ${ip.city || 'Unknown'}, ${ip.country || 'Unknown'}</p>
            </div>
        `;
        
        // Warnings
        if (warnings.length > 0) {
            resultHTML += `<h3>üîç Findings:</h3><ul style="background:#fff3cd; padding:15px 15px 15px 30px; border-radius:8px;">`;
            warnings.forEach(warning => {
                resultHTML += `<li>${warning}</li>`;
            });
            resultHTML += `</ul>`;
        }
        
        // Interpretation for normal phones
        if (distance > 20000 && distance < 100000) {
            resultHTML += `
                <div style="background:#e7f3ff; padding:15px; border-radius:8px; margin:15px 0;">
                    <p><strong>üì± Normal Phone Behavior Detected:</strong></p>
                    <p>GPS vs IP distance of ${Math.round(distance/1000)}km is normal for mobile phones.
                    Mobile IP locations are based on your ISP's network center, not your exact location.</p>
                </div>
            `;
        }
        
        // Copy button for Rocket.Chat
        const mapUrl = `https://maps.google.com/?q=${gps.lat},${gps.lon}`;
        const message = `üìç Verified Location | Trust Score: ${trustScore}/100
Latitude: ${gps.lat.toFixed(6)}
Longitude: ${gps.lon.toFixed(6)}
Accuracy: ${Math.round(gps.accuracy)} meters
Map: ${mapUrl}
Time: ${new Date().toLocaleString()}`;
        
        resultHTML += `
            <h3>üìã Copy for Rocket.Chat:</h3>
            <textarea id="locationText" rows="6">${message}</textarea>
            <button class="btn" onclick="copyToClipboard()">üìã Copy to Clipboard</button>
        `;
        
        document.getElementById('result').innerHTML = `
            <div class="result ${resultClass}">
                ${resultHTML}
            </div>
        `;
    }
    
    // Utility functions
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const œÜ1 = lat1 * Math.PI/180;
        const œÜ2 = lat2 * Math.PI/180;
        const ŒîœÜ = (lat2-lat1) * Math.PI/180;
        const ŒîŒª = (lon2-lon1) * Math.PI/180;
        
        const a = Math.sin(ŒîœÜ/2)*Math.sin(ŒîœÜ/2) +
                Math.cos(œÜ1)*Math.cos(œÜ2)*
                Math.sin(ŒîŒª/2)*Math.sin(ŒîŒª/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
    }
    
    function showStatus(message, type) {
        const colors = {
            info: '#d1ecf1',
            error: '#f8d7da',
            success: '#d4edda'
        };
        
        document.getElementById('status').innerHTML = `
            <div style="padding:15px; background:${colors[type] || '#fff3cd'}; border-radius:8px; margin:10px 0;">
                ${message}
            </div>
        `;
    }
    
    function copyToClipboard() {
        const textarea = document.getElementById('locationText');
        textarea.select();
        document.execCommand('copy');
        
        const btn = event.target;
        const original = btn.innerHTML;
        btn.innerHTML = '‚úÖ Copied!';
        setTimeout(() => btn.innerHTML = original, 2000);
    }
    
    // Initialize
    window.addEventListener('load', () => {
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
            document.querySelector('.subtitle').innerHTML += '<br><small>üì± Mobile optimized - understands normal GPS vs IP differences</small>';
        }
    });
    </script>
</body>
</html>
